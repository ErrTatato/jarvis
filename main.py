import os
import sys
import logging
import asyncio
import json
import io
import re
import ssl
from pathlib import Path
from typing import Dict, Optional, Any

import uvicorn
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
from openai import OpenAI
import httpx

try:
    from google.cloud import texttospeech
    GOOGLE_TTS_AVAILABLE = True
except ImportError:
    GOOGLE_TTS_AVAILABLE = False

# ===== LOGGING =====
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)s: %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger("JARVIS")

# ===== PATHS =====
BASE_DIR = Path(__file__).parent
UI_DIR = BASE_DIR / "ui"
CERTS_DIR = BASE_DIR / "certs"

# ===== CONFIG =====
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    logger.error("❌ FATAL: OPENAI_API_KEY not set!")
    sys.exit(1)

OPENWEATHER_API_KEY = os.environ.get("OPENWEATHER_API_KEY", "demo")
DEVICE_SERVER_URL = os.environ.get("DEVICE_SERVER_URL", "http://localhost:5001")
PRIMARY_DEVICE_ID = os.environ.get("JARVIS_PRIMARY_DEVICE_ID", "mi13pro")

# ===== HTTPS CONFIG =====
USE_HTTPS = os.environ.get("USE_HTTPS", "true").lower() == "true"

# Tailscale cert paths (auto-generated by Tailscale)
TAILSCALE_CERT_PATH = CERTS_DIR / "tailscale" / "host.crt"
TAILSCALE_KEY_PATH = CERTS_DIR / "tailscale" / "host.key"

# Fallback to local certs if Tailscale not available
LOCAL_CERT_PATH = CERTS_DIR / "cert.pem"
LOCAL_KEY_PATH = CERTS_DIR / "key.pem"

# Determina quale certificato usare
CERT_PATH = None
KEY_PATH = None

if TAILSCALE_CERT_PATH.exists() and TAILSCALE_KEY_PATH.exists():
    CERT_PATH = TAILSCALE_CERT_PATH
    KEY_PATH = TAILSCALE_KEY_PATH
    logger.info("✅ Using Tailscale certificates")
elif LOCAL_CERT_PATH.exists() and LOCAL_KEY_PATH.exists():
    CERT_PATH = LOCAL_CERT_PATH
    KEY_PATH = LOCAL_KEY_PATH
    logger.info("✅ Using local certificates")
else:
    if USE_HTTPS:
        logger.warning("⚠️ HTTPS requested but no certificates found!")
        logger.info("📝 To generate self-signed certs, run:")
        logger.info("   openssl req -x509 -newkey rsa:4096 -nodes -out certs/cert.pem -keyout certs/key.pem -days 365")
        USE_HTTPS = False

# ===== SSL CONTEXT =====
ssl_context = None
if USE_HTTPS and CERT_PATH and KEY_PATH:
    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    ssl_context.load_cert_chain(str(CERT_PATH), str(KEY_PATH))
    logger.info("🔒 SSL context loaded")

# ===== CLIENTS =====
openai_client = OpenAI(api_key=OPENAI_API_KEY)

google_tts_client = None
if GOOGLE_TTS_AVAILABLE:
    try:
        google_tts_client = texttospeech.TextToSpeechClient()
        logger.info("✅ Google TTS available")
    except Exception as e:
        logger.warning(f"Google TTS unavailable: {e}")

# ===== SYSTEM PROMPT =====
SYSTEM_PROMPT = """Sei JARVIS, il maggiordomo intelligente di Tony Stark.
Tono sofisticato, elegante, sarcastico, britannico.
Risposte BREVI (max 30 parole). 100% ITALIANO PURO."""

# ===== FASTAPI =====
app = FastAPI(title="JARVIS", version="4.1.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

if UI_DIR.exists():
    app.mount("/static", StaticFiles(directory=UI_DIR, html=True), name="static")
    logger.info("✅ UI loaded")

# ===== MODELS =====
class Message(BaseModel):
    message: str
    audio: bool = True
    device_id: Optional[str] = None

# ===== INTENT DETECTION =====

async def detect_intent(text: str) -> str:
    """Detect intent from user text"""
    text_lower = text.lower()
    
    if any(w in text_lower for w in ["meteo", "tempo", "pioggia", "temperatura", "caldo", "freddo"]):
        return "weather"
    if any(w in text_lower for w in ["chiama", "call", "telefona"]):
        return "call"
    if any(w in text_lower for w in ["whatsapp", "messaggio"]):
        return "whatsapp"
    if any(w in text_lower for w in ["sms"]):
        return "sms"
    if any(w in text_lower for w in ["notifiche", "notifica"]):
        return "notifications"
    if any(w in text_lower for w in ["ciao", "salve", "buongiorno", "come stai"]):
        return "greeting"
    
    return "general"

# ===== WEATHER =====

async def get_weather(location: str = "Milano") -> str:
    """Get weather from OpenWeather API"""
    try:
        async with httpx.AsyncClient() as client:
            params = {
                "q": location,
                "appid": OPENWEATHER_API_KEY,
                "units": "metric",
                "lang": "it"
            }
            
            response = await client.get(
                "https://api.openweathermap.org/data/2.5/weather",
                params=params,
                timeout=5.0
            )
            data = response.json()
            
            if response.status_code == 200:
                temp = data["main"]["temp"]
                description = data["weather"][0]["description"]
                humidity = data["main"]["humidity"]
                return f"A {location}: {description}, {temp}°C, umidità {humidity}%."
            return f"Meteo non disponibile."
    except Exception as e:
        logger.error(f"Weather error: {e}")
        return "Sistema meteo offline."

# ===== DEVICE ACTIONS =====

async def send_device_command(device_id: str, action: str, data: Dict = None) -> Dict:
    """Send command to Android device via HTTP bridge"""
    try:
        async with httpx.AsyncClient(timeout=10) as client:
            payload = {
                "action": action,
                "device_id": device_id,
                "data": data or {}
            }
            
            response = await client.post(
                f"{DEVICE_SERVER_URL}/command",
                json=payload
            )
            
            return response.json()
    except Exception as e:
        logger.error(f"Device command error: {e}")
        return {"status": "error", "message": str(e)}

def extract_contact_name(text: str) -> str:
    """Extract contact name from command"""
    parts = text.split()
    if len(parts) > 1:
        return parts[1]
    return ""

# ===== HANDLERS =====

async def handle_weather(text: str) -> str:
    """Handle weather requests"""
    location = "Milano"
    if " a " in text.lower():
        location = text.lower().split(" a ")[-1].strip().title()
    return await get_weather(location)

async def handle_call(text: str, device_id: str) -> str:
    """Handle call requests"""
    contact = extract_contact_name(text)
    if not contact:
        return "Chi devo chiamare?"
    
    result = await send_device_command(device_id, "call_start", {"contact": contact})
    return f"📞 Sto chiamando {contact}." if result.get("status") == "success" else f"Errore: {result.get('message')}"

async def handle_whatsapp(text: str, device_id: str) -> str:
    """Handle WhatsApp requests"""
    parts = text.split(None, 1)
    if not parts:
        return "Chi devo contattare su WhatsApp?"
    
    contact = parts[0]
    message = parts[1] if len(parts) > 1 else ""
    
    result = await send_device_command(device_id, "whatsapp_send", {
        "contact": contact,
        "message": message
    })
    return f"💬 Apro WhatsApp con {contact}." if result.get("status") == "success" else f"Errore: {result.get('message')}"

async def handle_sms(text: str, device_id: str) -> str:
    """Handle SMS requests"""
    parts = text.split(None, 1)
    if not parts:
        return "Chi devo contattare?"
    
    contact = parts[0]
    message = parts[1] if len(parts) > 1 else ""
    
    result = await send_device_command(device_id, "sms_send", {
        "contact": contact,
        "message": message
    })
    return f"📨 Inviando SMS a {contact}." if result.get("status") == "success" else f"Errore: {result.get('message')}"

async def handle_notifications(device_id: str) -> str:
    """Handle notification requests"""
    result = await send_device_command(device_id, "notifications_read")
    if result.get("status") == "success":
        notifications = result.get("data", [])
        if notifications:
            notif_list = "\n".join([f"• {n.get('app')}: {n.get('text')}" for n in notifications])
            return f"📱 Notifiche:\n{notif_list}"
        return "Nessuna notifica non letta."
    return "Errore lettura notifiche."

async def handle_greeting() -> str:
    """Handle greeting"""
    return "Buongiorno, signore. Come posso assistervi?"

# ===== GET RESPONSE =====

async def get_response(user_input: str, device_id: Optional[str] = None) -> str:
    """Get JARVIS response"""
    try:
        intent = await detect_intent(user_input)
        device_id = device_id or PRIMARY_DEVICE_ID
        
        if intent == "weather":
            return await handle_weather(user_input)
        elif intent == "call":
            return await handle_call(user_input, device_id)
        elif intent == "whatsapp":
            parts = user_input.split(None, 1)
            return await handle_whatsapp(parts[1] if len(parts) > 1 else "", device_id)
        elif intent == "sms":
            parts = user_input.split(None, 1)
            return await handle_sms(parts[1] if len(parts) > 1 else "", device_id)
        elif intent == "notifications":
            return await handle_notifications(device_id)
        elif intent == "greeting":
            return await handle_greeting()
        else:
            response = openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": SYSTEM_PROMPT},
                    {"role": "user", "content": user_input}
                ],
                temperature=0.7,
                max_tokens=50
            )
            return response.choices[0].message.content.strip()
    
    except Exception as e:
        logger.error(f"Response error: {e}")
        return "Scuso, sistema momentaneamente offline."

# ===== TEXT TO SPEECH =====

async def text_to_speech_google(text: str) -> Optional[bytes]:
    """Google TTS - Italian"""
    if not google_tts_client:
        return None
    
    try:
        synthesis_input = texttospeech.SynthesisInput(text=text)
        voice = texttospeech.VoiceSelectionParams(
            language_code="it-IT",
            name="it-IT-Neural2-A"
        )
        audio_config = texttospeech.AudioConfig(
            audio_encoding=texttospeech.AudioEncoding.MP3
        )
        
        response = google_tts_client.synthesize_speech(
            input=synthesis_input,
            voice=voice,
            audio_config=audio_config
        )
        
        logger.info(f"🎙️ Google TTS: {len(text)} chars")
        return response.audio_content
    except Exception as e:
        logger.error(f"Google TTS error: {e}")
        return None

async def text_to_speech(text: str) -> Optional[bytes]:
    """TTS with fallback (Google → OpenAI)"""
    google_audio = await text_to_speech_google(text)
    if google_audio:
        return google_audio
    
    try:
        response = openai_client.audio.speech.create(
            model="tts-1-hd",
            voice="onyx",
            input=text,
            speed=1.0
        )
        logger.info(f"🎙️ OpenAI TTS: {len(text)} chars")
        return response.content
    except Exception as e:
        logger.error(f"TTS error: {e}")
        return None

async def speech_to_text(audio_file) -> Optional[str]:
    """Whisper for transcription"""
    try:
        audio_data = await audio_file.read()
        response = openai_client.audio.transcriptions.create(
            model="whisper-1",
            file=("audio.wav", io.BytesIO(audio_data), "audio/wav"),
            language="it"
        )
        return response.text.strip()
    except Exception as e:
        logger.error(f"Whisper error: {e}")
        return None

# ===== ENDPOINTS =====

@app.get("/")
async def root():
    """Serve UI"""
    index_file = UI_DIR / "index.html"
    if index_file.exists():
        return FileResponse(index_file)
    return HTMLResponse("<h1>✅ JARVIS v4.1.0</h1>")

@app.get("/api/health")
async def health():
    """Health check"""
    return {
        "status": "ok",
        "version": "4.1.0",
        "mode": "production",
        "protocol": "HTTPS" if USE_HTTPS else "HTTP",
        "tts": "Google (Italiano)" if google_tts_client else "OpenAI",
        "device_server": DEVICE_SERVER_URL
    }

@app.post("/api/chat-with-voice")
async def chat_with_voice(data: Message):
    """Chat with voice response"""
    user_msg = data.message.strip()
    if not user_msg or len(user_msg) < 2:
        return {"error": "Messaggio troppo breve."}
    
    reply = await get_response(user_msg, data.device_id)
    audio_bytes = await text_to_speech(reply)
    
    if not audio_bytes:
        return {"response": reply, "status": "text_only"}
    
    import base64
    audio_base64 = base64.b64encode(audio_bytes).decode()
    
    return {
        "response": reply,
        "status": "ok",
        "audio_base64": audio_base64
    }

# ===== WEBSOCKETS =====

@app.websocket("/ws/jarvis")
async def websocket_jarvis(websocket: WebSocket):
    """WebSocket for real-time chat"""
    await websocket.accept()
    logger.info("🌐 Connected")
    
    device_id = PRIMARY_DEVICE_ID
    
    await websocket.send_json({
        "status": "connected",
        "message": "Buongiorno, signore."
    })
    
    try:
        while True:
            data = await websocket.receive_text()
            
            try:
                msg = json.loads(data)
                user_input = (msg.get("message") or "").strip()
                return_audio = msg.get("audio", True)
                device_id = msg.get("device_id", PRIMARY_DEVICE_ID)
                
                if not user_input or len(user_input) < 2:
                    continue
                
                logger.info(f"📝 Input: {user_input}")
                await websocket.send_json({"status": "processing"})
                
                reply = await get_response(user_input, device_id)
                
                response_data = {
                    "response": reply,
                    "status": "ok",
                    "has_audio": False
                }
                
                if return_audio:
                    audio_bytes = await text_to_speech(reply)
                    if audio_bytes:
                        import base64
                        audio_base64 = base64.b64encode(audio_bytes).decode()
                        response_data["audio_base64"] = audio_base64
                        response_data["has_audio"] = True
                
                await websocket.send_json(response_data)
            except json.JSONDecodeError:
                pass
    except:
        logger.info("🌐 Disconnected")

# ===== STARTUP =====

@app.on_event("startup")
async def startup():
    logger.info("=" * 70)
    logger.info("🤖 JARVIS v4.1.0 - PRODUCTION HTTPS")
    logger.info("💬 Chat + Voice + Device Control")
    logger.info("🎙️ TTS: Google (100% Italiano) + OpenAI fallback")
    logger.info(f"🔒 Protocol: {'HTTPS' if USE_HTTPS else 'HTTP'}")
    logger.info(f"📱 Device Server: {DEVICE_SERVER_URL}")
    logger.info("=" * 70)

# ===== MAIN =====

if __name__ == "__main__":
    # Port configuration
    port = int(os.environ.get("JARVIS_PORT", "5000"))
    host = os.environ.get("JARVIS_HOST", "0.0.0.0")
    
    config = uvicorn.Config(
        app=app,
        host=host,
        port=port,
        ssl_keyfile=str(KEY_PATH) if USE_HTTPS and KEY_PATH else None,
        ssl_certfile=str(CERT_PATH) if USE_HTTPS and CERT_PATH else None,
        log_level="info",
        access_log=False
    )
    
    server = uvicorn.Server(config)
    
    try:
        asyncio.run(server.serve())
    except KeyboardInterrupt:
        logger.info("✅ Arrivederci.")
        sys.exit(0)